/*
The Below API is an implementation of the TWI or Two Wire Interface.


In TWI the serial data transmission is done in asynchronous mode.
This protocol uses only two wires for communicating between two or more ICs.
The two bidirectional open drain lines named SDA (Serial Data) and SCL (Serial Clock) with pull up resistors are used for data transfer between devices.

The current API is as follows:

output on/off I2C;// emit I2C to start or stop
output (u8,byte&&,u8) I2C_REQUEST_SEND;// emit request to send 
output (u8,byte&&,u8) I2C_REQUEST_RECEIVE;// emit request to receive
input (u8,u8) I2C_REQUEST_DONE;// await the status of the 


Example : samples/    // to be filled later
*/
#ifndef CEU_I2C
#define CEU_I2C
    //////////////////////TWI
    #include "arduino/avr.ceu"
    #include "arduino/arduino.ceu"
    
    native/pre do
        ##include <util/twi.h>
        #ifndef TWI_FREQ
        #define TWI_FREQ 100000L
        #endif

        #ifndef TWI_BUFFER_LENGTH
        #define TWI_BUFFER_LENGTH 32
        #endif

        #define TWI_READY 0
        #define TWI_MRX   1
        #define TWI_MTX   2
        #define TWI_SRX   3
        #define TWI_STX   4


        #ifndef cbi
        #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
        #endif

        #ifndef sbi
        #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
        #endif
    
        static volatile uint8_t twi_state;
        static volatile uint8_t twi_slarw;
        static volatile uint8_t twi_sendStop;			
        static volatile uint8_t twi_inRepStart;			

        static void (*twi_onSlaveTransmit)(void);
        static void (*twi_onSlaveReceive)(uint8_t*, int);

        static uint8_t twi_masterBuffer[TWI_BUFFER_LENGTH];
        static volatile uint8_t twi_masterBufferIndex;
        static volatile uint8_t twi_masterBufferLength;

        static uint8_t twi_txBuffer[TWI_BUFFER_LENGTH];
        static volatile uint8_t twi_txBufferIndex;
        static volatile uint8_t twi_txBufferLength;

        static uint8_t twi_rxBuffer[TWI_BUFFER_LENGTH];
        static volatile uint8_t twi_rxBufferIndex;

        static volatile uint8_t twi_error;
        void twi_init(void)
        {
            // initialize state
            twi_state = TWI_READY;
            twi_sendStop = true;		// default value
            twi_inRepStart = false;
            
            // activate internal pullups for twi.
            digitalWrite(SDA, 1);
            digitalWrite(SCL, 1);

            // initialize twi prescaler and bit rate
            cbi(TWSR, TWPS0);
            cbi(TWSR, TWPS1);
            TWBR = ((F_CPU / TWI_FREQ) - 16) / 2;

            /* twi bit rate formula from atmega128 manual pg 204
            SCL Frequency = CPU Clock Frequency / (16 + (2 * TWBR))
            note: TWBR should be 10 or higher for master mode
            It is 72 for a 16mhz Wiring board with 100kHz TWI */

            // enable twi module, acks, and twi interrupt
            TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA);
        }

        void twi_disable(void)
        {
        // disable twi module, acks, and twi interrupt
        TWCR &= ~(_BV(TWEN) | _BV(TWIE) | _BV(TWEA));

        // deactivate internal pullups for twi.
        digitalWrite(SDA, 0);
        digitalWrite(SCL, 0);
        }

        uint8_t twi_writeTo(uint8_t address, uint8_t* data, uint8_t length, uint8_t wait, uint8_t sendStop)
        {
        uint8_t i;

        // ensure data will fit into buffer
        if(TWI_BUFFER_LENGTH < length){
            return 1;
        }

        // wait until twi is ready, become master transmitter
        while(TWI_READY != twi_state){
            continue;
        }
        twi_state = TWI_MTX;
        twi_sendStop = sendStop;
        // reset error state (0xFF.. no error occured)
        twi_error = 0xFF;

        // initialize buffer iteration vars
        twi_masterBufferIndex = 0;
        twi_masterBufferLength = length;
        
        // copy data to twi buffer
        for(i = 0; i < length; ++i){
            twi_masterBuffer[i] = data[i];
        }
        
        // build sla+w, slave device address + w bit
        twi_slarw = TW_WRITE;
        twi_slarw |= address << 1;
        
        // if we're in a repeated start, then we've already sent the START
        // in the ISR. Don't do it again.
        //
        if (true == twi_inRepStart) {
            // if we're in the repeated start state, then we've already sent the start,
            // (@@@ we hope), and the TWI statemachine is just waiting for the address byte.
            // We need to remove ourselves from the repeated start state before we enable interrupts,
            // since the ISR is ASYNC, and we could get confused if we hit the ISR before cleaning
            // up. Also, don't enable the START interrupt. There may be one pending from the 
            // repeated start that we sent outselves, and that would really confuse things.
            twi_inRepStart = false;			// remember, we're dealing with an ASYNC ISR
            do {
            TWDR = twi_slarw;				
            } while(TWCR & _BV(TWWC));
            TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);	// enable INTs, but not START
        }
        else
            // send start condition
            TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE) | _BV(TWSTA);	// enable INTs

        // wait for write operation to complete
        while(wait && (TWI_MTX == twi_state)){
            continue;
        }
        
        if (twi_error == 0xFF)
            return 0;	// success
        else if (twi_error == TW_MT_SLA_NACK)
            return 2;	// error: address send, nack received
        else if (twi_error == TW_MT_DATA_NACK)
            return 3;	// error: data send, nack received
        else
            return 4;	// other twi error
        }

        uint8_t twi_readFrom(uint8_t address, uint8_t* data, uint8_t length, uint8_t sendStop)
        {
        uint8_t i;

        // ensure data will fit into buffer
        if(TWI_BUFFER_LENGTH < length){
            return 0;
        }

        // wait until twi is ready, become master receiver
        while(TWI_READY != twi_state){
            continue;
        }
        twi_state = TWI_MRX;
        twi_sendStop = sendStop;
        // reset error state (0xFF.. no error occured)
        twi_error = 0xFF;

        // initialize buffer iteration vars
        twi_masterBufferIndex = 0;
        twi_masterBufferLength = length-1;  // This is not intuitive, read on...
        // On receive, the previously configured ACK/NACK setting is transmitted in
        // response to the received byte before the interrupt is signalled. 
        // Therefor we must actually set NACK when the _next_ to last byte is
        // received, causing that NACK to be sent in response to receiving the last
        // expected byte of data.

        // build sla+w, slave device address + w bit
        twi_slarw = TW_READ;
        twi_slarw |= address << 1;

        if (true == twi_inRepStart) {
            // if we're in the repeated start state, then we've already sent the start,
            // (@@@ we hope), and the TWI statemachine is just waiting for the address byte.
            // We need to remove ourselves from the repeated start state before we enable interrupts,
            // since the ISR is ASYNC, and we could get confused if we hit the ISR before cleaning
            // up. Also, don't enable the START interrupt. There may be one pending from the 
            // repeated start that we sent ourselves, and that would really confuse things.
            twi_inRepStart = false;			// remember, we're dealing with an ASYNC ISR
            do {
            TWDR = twi_slarw;
            } while(TWCR & _BV(TWWC));
            TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);	// enable INTs, but not START
        }
        else
            // send start condition
            TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTA);

        // wait for read operation to complete
        while(TWI_MRX == twi_state){
            continue;
        }

        if (twi_masterBufferIndex < length)
            length = twi_masterBufferIndex;

        // copy twi buffer to data
        for(i = 0; i < length; ++i){
            data[i] = twi_masterBuffer[i];
        }
            
        return length;
        }


        void twi_reply(uint8_t ack)
        {
        // transmit master read ready signal, with or without ack
        if(ack){
            TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
        }else{
            TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
        }
        }

        void twi_stop(void)
        {
        // send stop condition
        TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);

        // wait for stop condition to be exectued on bus
        // TWINT is not set after a stop condition!
        while(TWCR & _BV(TWSTO)){
            continue;
        }
        twi_state = TWI_READY;
        }

        void twi_releaseBus(void)
        {
        // release bus
        TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);

        // update twi state
        twi_state = TWI_READY;
        }
    end
    native
        _twi_init,
        _twi_disable,
        _twi_readFrom,
    ;
    native/nohold _twi_writeTo;
    /////////////////////Wire

    #define BUFFER_LENGTH 32

    // WIRE_HAS_END means Wire has end()
    #define WIRE_HAS_END 1
    var[BUFFER_LENGTH] u8 rxBuffer;
    var u8 rxBufferIndex = 0;
    var u8 rxBufferLength = 0;

    var u8 txAddress = 0;
    var[BUFFER_LENGTH] byte txBuffer;
    var u8 txBufferIndex = 0;
    var u8 txBufferLength = 0;

    var u8 transmitting = 0;

    output on/off I2C;

    output (on/off v) I2C do
        if v then
            outer.rxBufferIndex = 0;
            outer.rxBufferLength = 0;
            outer.txBufferIndex = 0;
            outer.txBufferLength = 0;
            _twi_init();
        else
            _twi_disable();
        end
    end
    
    output (u8,byte&&,u8) I2C_REQUEST_SEND;
    var u8 send_STATUS=1;
    output (u8,byte&&,u8) I2C_REQUEST_RECEIVE;
    input (u8,u8) I2C_REQUEST_DONE;

    output (u8 address,byte&& buffer,u8 number_of_bytes) I2C_REQUEST_SEND do

        // indicate that we are transmitting
        outer.transmitting = 1;
        // set address of targeted slave
        outer.txAddress = address;
        // reset tx buffer iterator vars
        outer.txBufferIndex = 0;
        outer.txBufferLength = 0;
        outer.send_STATUS=1;
        var u8 i;
    
        loop i in [0 -> number_of_bytes] do
            
            if outer.txBufferLength >= BUFFER_LENGTH then
                outer.send_STATUS=0;
            else
                // put byte in tx buffer
                outer.txBuffer[outer.txBufferIndex] = *buffer;
                outer.txBufferIndex=outer.txBufferIndex+1;
                // update amount in buffer   
                outer.txBufferLength = outer.txBufferIndex;
            end
            
        end
    
        var u8 ret = _twi_writeTo(outer.txAddress, &&outer.txBuffer as u8, outer.txBufferLength, 1, 1);
        // reset tx buffer iterator vars
        outer.txBufferIndex = 0;
        outer.txBufferLength = 0;
        // indicate that we are done transmitting
        outer.transmitting = 0;
        //return ret;
    end

    output (u8 address,byte&& buffer,u8 number_of_bytes) I2C_REQUEST_RECEIVE do
        
        // clamp to buffer length
        if number_of_bytes > BUFFER_LENGTH then
            number_of_bytes = BUFFER_LENGTH;
        end
        
        // perform blocking read into buffer
        var u8 read = _twi_readFrom(address, &&outer.rxBuffer as u8, number_of_bytes, 1);
        // set rx buffer iterator vars
        outer.rxBufferIndex = 0;
        outer.rxBufferLength = read;

        var int i;
        i=0;
        loop do
            if outer.rxBufferLength - outer.rxBufferIndex <= 0 then
                break;
            end
            
            var int value = -1;
            if outer.rxBufferIndex < outer.rxBufferLength then
                value = outer.rxBuffer[outer.rxBufferIndex] as int;
                outer.rxBufferIndex=outer.rxBufferIndex+1;
            end

            //buffer[i] = value;
            *buffer = value as byte;
            i=i+1;
        end
    end

    spawn async/isr [_TWI_vect_num,0] do
        {
        switch(TW_STATUS){
            // All Master
            case TW_START:     // sent start condition
            case TW_REP_START: // sent repeated start condition
            // copy device address and r/w bit to output register and ack
            TWDR = twi_slarw;
            twi_reply(1);
            break;

            // Master Transmitter
            case TW_MT_SLA_ACK:  // slave receiver acked address
            case TW_MT_DATA_ACK: // slave receiver acked data
            // if there is data to send, send it, otherwise stop 
            if(twi_masterBufferIndex < twi_masterBufferLength){
                // copy data to output register and ack
                TWDR = twi_masterBuffer[twi_masterBufferIndex++];
                twi_reply(1);
            }else{
            if (twi_sendStop)
                twi_stop();
            else {
            twi_inRepStart = true;	// we're gonna send the START
            // don't enable the interrupt. We'll generate the start, but we 
            // avoid handling the interrupt until we're in the next transaction,
            // at the point where we would normally issue the start.
            TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
            twi_state = TWI_READY;
            }
            }
            break;
            case TW_MT_SLA_NACK:  // address sent, nack received
            twi_error = TW_MT_SLA_NACK;
            twi_stop();
            break;
            case TW_MT_DATA_NACK: // data sent, nack received
            twi_error = TW_MT_DATA_NACK;
            twi_stop();
            break;
            case TW_MT_ARB_LOST: // lost bus arbitration
            twi_error = TW_MT_ARB_LOST;
            twi_releaseBus();
            break;

            // Master Receiver
            case TW_MR_DATA_ACK: // data received, ack sent
            // put byte into buffer
            twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
            case TW_MR_SLA_ACK:  // address sent, ack received
            // ack if more bytes are expected, otherwise nack
            if(twi_masterBufferIndex < twi_masterBufferLength){
                twi_reply(1);
            }else{
                twi_reply(0);
            }
            break;
            case TW_MR_DATA_NACK: // data received, nack sent
            // put final byte into buffer
            twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
            if (twi_sendStop)
                twi_stop();
            else {
            twi_inRepStart = true;	// we're gonna send the START
            // don't enable the interrupt. We'll generate the start, but we 
            // avoid handling the interrupt until we're in the next transaction,
            // at the point where we would normally issue the start.
            TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
            twi_state = TWI_READY;
            }    
            break;
            case TW_MR_SLA_NACK: // address sent, nack received
            twi_stop();
            break;
            // TW_MR_ARB_LOST handled by TW_MT_ARB_LOST case

            // Slave Receiver
            case TW_SR_SLA_ACK:   // addressed, returned ack
            case TW_SR_GCALL_ACK: // addressed generally, returned ack
            case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack
            case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack
            // enter slave receiver mode
            twi_state = TWI_SRX;
            // indicate that rx buffer can be overwritten and ack
            twi_rxBufferIndex = 0;
            twi_reply(1);
            break;
            case TW_SR_DATA_ACK:       // data received, returned ack
            case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack
            // if there is still room in the rx buffer
            if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
                // put byte in buffer and ack
                twi_rxBuffer[twi_rxBufferIndex++] = TWDR;
                twi_reply(1);
            }else{
                // otherwise nack
                twi_reply(0);
            }
            break;
            case TW_SR_STOP: // stop or repeated start condition received
            // ack future responses and leave slave receiver state
            twi_releaseBus();
            // put a null char after data if there's room
            if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
                twi_rxBuffer[twi_rxBufferIndex] = '\0';
            }
            // callback to user defined callback
            twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);
            // since we submit rx buffer to "wire" library, we can reset it
            twi_rxBufferIndex = 0;
            break;
            case TW_SR_DATA_NACK:       // data received, returned nack
            case TW_SR_GCALL_DATA_NACK: // data received generally, returned nack
            // nack back at master
            twi_reply(0);
            break;
            
            // Slave Transmitter
            case TW_ST_SLA_ACK:          // addressed, returned ack
            case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack
            // enter slave transmitter mode
            twi_state = TWI_STX;
            // ready the tx buffer index for iteration
            twi_txBufferIndex = 0;
            // set tx buffer length to be zero, to verify if user changes it
            twi_txBufferLength = 0;
            // request for txBuffer to be filled and length to be set
            // note: user must call twi_transmit(bytes, length) to do this
            twi_onSlaveTransmit();
            // if they didn't change buffer & length, initialize it
            if(0 == twi_txBufferLength){
                twi_txBufferLength = 1;
                twi_txBuffer[0] = 0x00;
            }
            // transmit first byte from buffer, fall
            case TW_ST_DATA_ACK: // byte sent, ack returned
            // copy data to output register
            TWDR = twi_txBuffer[twi_txBufferIndex++];
            // if there is more to send, ack, otherwise nack
            if(twi_txBufferIndex < twi_txBufferLength){
                twi_reply(1);
            }else{
                twi_reply(0);
            }
            break;
            case TW_ST_DATA_NACK: // received nack, we are done 
            case TW_ST_LAST_DATA: // received ack, but we are done already!
            // ack future responses
            twi_reply(1);
            // leave slave receiver state
            twi_state = TWI_READY;
            break;

            // All
            case TW_NO_INFO:   // no state information
            break;
            case TW_BUS_ERROR: // bus error, illegal stop/start
            twi_error = TW_BUS_ERROR;
            twi_stop();
            break;
        }
        }
        emit I2C_REQUEST_DONE(1,1);
    end
#endif