#ifndef CEU_I2C
#define CEU_I2C
    //////////////////////TWI
    #include "arduino/avr.ceu"
    #include "arduino/arduino.ceu"
    
    native/pre do
        ##include <util/twi.h>
        ##include <compat/twi.h>
        #ifndef TWI_FREQ
        #define TWI_FREQ 100000L
        #endif

        #ifndef TWI_BUFFER_LENGTH
        #define TWI_BUFFER_LENGTH 32
        #endif

        #define TWI_READY 0
        #define TWI_MRX   1
        #define TWI_MTX   2
        #define TWI_SRX   3
        #define TWI_STX   4


        #ifndef cbi
        #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
        #endif

        #ifndef sbi
        #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
        #endif
    
        static volatile uint8_t twi_state;
        static volatile uint8_t twi_slarw;
        static volatile uint8_t twi_sendStop;			// should the transaction end with a stop
        static volatile uint8_t twi_inRepStart;			// in the middle of a repeated start

        static void (*twi_onSlaveTransmit)(void);
        static void (*twi_onSlaveReceive)(uint8_t*, int);

        static uint8_t twi_masterBuffer[TWI_BUFFER_LENGTH];
        static volatile uint8_t twi_masterBufferIndex;
        static volatile uint8_t twi_masterBufferLength;

        static uint8_t twi_txBuffer[TWI_BUFFER_LENGTH];
        static volatile uint8_t twi_txBufferIndex;
        static volatile uint8_t twi_txBufferLength;

        static uint8_t twi_rxBuffer[TWI_BUFFER_LENGTH];
        static volatile uint8_t twi_rxBufferIndex;

        static volatile uint8_t twi_error;
        void twi_init(void)
        {
            // initialize state
            twi_state = TWI_READY;
            twi_sendStop = true;		// default value
            twi_inRepStart = false;
            
            // activate internal pullups for twi.
            digitalWrite(SDA, 1);
            digitalWrite(SCL, 1);

            // initialize twi prescaler and bit rate
            cbi(TWSR, TWPS0);
            cbi(TWSR, TWPS1);
            TWBR = ((F_CPU / TWI_FREQ) - 16) / 2;

            /* twi bit rate formula from atmega128 manual pg 204
            SCL Frequency = CPU Clock Frequency / (16 + (2 * TWBR))
            note: TWBR should be 10 or higher for master mode
            It is 72 for a 16mhz Wiring board with 100kHz TWI */

            // enable twi module, acks, and twi interrupt
            TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA);
        }

        void twi_disable(void)
        {
        // disable twi module, acks, and twi interrupt
        TWCR &= ~(_BV(TWEN) | _BV(TWIE) | _BV(TWEA));

        // deactivate internal pullups for twi.
        digitalWrite(SDA, 0);
        digitalWrite(SCL, 0);
        }

        uint8_t twi_writeTo(uint8_t address, uint8_t* data, uint8_t length, uint8_t wait, uint8_t sendStop)
        {
        uint8_t i;

        // ensure data will fit into buffer
        if(TWI_BUFFER_LENGTH < length){
            return 1;
        }

        // wait until twi is ready, become master transmitter
        while(TWI_READY != twi_state){
            continue;
        }
        twi_state = TWI_MTX;
        twi_sendStop = sendStop;
        // reset error state (0xFF.. no error occured)
        twi_error = 0xFF;

        // initialize buffer iteration vars
        twi_masterBufferIndex = 0;
        twi_masterBufferLength = length;
        
        // copy data to twi buffer
        for(i = 0; i < length; ++i){
            twi_masterBuffer[i] = data[i];
        }
        
        // build sla+w, slave device address + w bit
        twi_slarw = TW_WRITE;
        twi_slarw |= address << 1;
        
        // if we're in a repeated start, then we've already sent the START
        // in the ISR. Don't do it again.
        //
        if (true == twi_inRepStart) {
            // if we're in the repeated start state, then we've already sent the start,
            // (@@@ we hope), and the TWI statemachine is just waiting for the address byte.
            // We need to remove ourselves from the repeated start state before we enable interrupts,
            // since the ISR is ASYNC, and we could get confused if we hit the ISR before cleaning
            // up. Also, don't enable the START interrupt. There may be one pending from the 
            // repeated start that we sent outselves, and that would really confuse things.
            twi_inRepStart = false;			// remember, we're dealing with an ASYNC ISR
            do {
            TWDR = twi_slarw;				
            } while(TWCR & _BV(TWWC));
            TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);	// enable INTs, but not START
        }
        else
            // send start condition
            TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE) | _BV(TWSTA);	// enable INTs

        // wait for write operation to complete
        while(wait && (TWI_MTX == twi_state)){
            continue;
        }
        
        if (twi_error == 0xFF)
            return 0;	// success
        else if (twi_error == TW_MT_SLA_NACK)
            return 2;	// error: address send, nack received
        else if (twi_error == TW_MT_DATA_NACK)
            return 3;	// error: data send, nack received
        else
            return 4;	// other twi error
        }
    end
    native
        _twi_init,
        _twi_disable,
    ;
    native/nohold _twi_writeTo;
    /////////////////////Wire

    #define BUFFER_LENGTH 32

    // WIRE_HAS_END means Wire has end()
    #define WIRE_HAS_END 1
    var[BUFFER_LENGTH] u8 rxBuffer;
    var u8 rxBufferIndex = 0;
    var u8 rxBufferLength = 0;

    var u8 txAddress = 0;
    var[BUFFER_LENGTH] byte txBuffer;
    var u8 txBufferIndex = 0;
    var u8 txBufferLength = 0;

    var u8 transmitting = 0;

    output on/off I2C;

    output (on/off v) I2C do
        if v then
            outer.rxBufferIndex = 0;
            outer.rxBufferLength = 0;
            outer.txBufferIndex = 0;
            outer.txBufferLength = 0;
            _twi_init();
        else
            _twi_disable();
        end
    end
    
    output (u8,byte&&,u8) I2C_REQUEST_SEND;
    var u8 send_STATUS=1;
    output (u8,byte&&,u8) I2C_REQUEST_RECEIVE;
    input u8 I2C_REQUEST_DONE;

    output (u8 address,byte&& buffer,u8 number_of_bytes) I2C_REQUEST_SEND do

        // indicate that we are transmitting
        outer.transmitting = 1;
        // set address of targeted slave
        outer.txAddress = address;
        // reset tx buffer iterator vars
        outer.txBufferIndex = 0;
        outer.txBufferLength = 0;
        outer.send_STATUS=1;
        var u8 i;
    /*
        loop i in [0 -> number_of_bytes] do
            
            if outer.txBufferLength >= BUFFER_LENGTH then
                outer.send_STATUS=0;
            else
                // put byte in tx buffer
                outer.txBuffer[outer.txBufferIndex] = *buffer;
                outer.txBufferIndex=outer.txBufferIndex+1;
                // update amount in buffer   
                outer.txBufferLength = outer.txBufferIndex;
            end
            
        end
    */
        var u8 ret = _twi_writeTo(outer.txAddress, &&outer.txBuffer as u8, outer.txBufferLength, 1, 1);
        // reset tx buffer iterator vars
        outer.txBufferIndex = 0;
        outer.txBufferLength = 0;
        // indicate that we are done transmitting
        outer.transmitting = 0;
        //return ret;
    end
    
#endif