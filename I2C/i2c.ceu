/*
The Below API is an implementation of the TWI or Two Wire Interface.


In TWI the serial data transmission is done in asynchronous mode.
This protocol uses only two wires for communicating between two or more ICs.
The two bidirectional open drain lines named SDA (Serial Data) and SCL (Serial Clock) with pull up resistors are used for data transfer between devices.

The current API is as follows:

output on/off I2C;// emit I2C to start or stop
output (u8,byte&&,u8) I2C_REQUEST_SEND;// emit request to send 
output (u8,byte&&,u8) I2C_REQUEST_RECEIVE;// emit request to receive
input (u8,u8) I2C_REQUEST_DONE;// await the status of the request


Example : samples/    // to be filled later
*/
//#include "../i2c.ceu"  the below is from the included file
output on/off         I2C;
output (u8,byte&&,u8) I2C_REQUEST_SEND;
output (u8,byte&&,u8) I2C_REQUEST_RECEIVE;
input  (u8,u8)        I2C_REQUEST_DONE;

var bool i2c_isMaster = true;
var u8 deviceAddress;
native/pre do
    #define TWI_FREQ 100000
    ##include <compat/twi.h>
    int getData;
    int sendData;
    int SLA=4;
end
native 
    _TWI_vect,
;
output (on/off v) I2C do
    if v then
    {

        //TWIInfo.mode = Ready;
        //TWIInfo.errorCode = 0xFF;
        //TWIInfo.repStart = 0;
        TWSR = 0;
        TWBR = ((F_CPU / TWI_FREQ) - 16) / 2;// Set bit rate
        TWCR = (1 << TWIE) | (1 << TWEN);// Enable TWI and interrupt
    }
    end
end

output (u8 address,byte&& buffer,u8 n_byte) I2C_REQUEST_SEND do
    // Then here...
    // Describe (in english) the steps involved for this requests according to
    // the protocol rules
    // In the original driver (or other code from the internet), what is the
    // first time that we need to check flags with a busy-wait while loop?
    // How can we avoid that? What is the interrupt and flags that we can use
    // instead of the busy-wait?
    // This will make you need the ISR...
    {

    }
end

output (u8 address,byte&& buffer,u8 n_byte) I2C_REQUEST_RECEIVE do
    // Then here...
    // Describe (in english) the steps involved for this requests according to
    // the protocol rules
    // In the original driver (or other code from the internet), what is the
    // first time that we need to check flags with a busy-wait while loop?
    // How can we avoid that? What is the interrupt and flags that we can use
    // instead of the busy-wait?
    // This will make you need the ISR...
    {

    }
end

spawn async/isr [_TWI_vect] do
{	// TWI interrupt service routine
  switch(TW_STATUS){
    case TW_START:
      // 2) send SLA+W
      TWDR = (SLA << 1) | TW_WRITE;
      TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWIE);
      break;
    
    case TW_MT_SLA_ACK:
      sendData = 0;
  	  if (!digitalRead(6)) sendData |= 1;
      if (!digitalRead(7)) sendData |= 1<<1;

      // 3) send data
      TWDR = sendData;
      TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWIE);
	  break;
    
    case TW_MT_DATA_ACK:
      // 4) send repeated start condition 
  	  TWCR = (1<<TWINT)|(1<<TWEN)| (1<<TWSTA) | (1<<TWIE);
	  break;
    
    case TW_REP_START: 
      // 5) send SLA+R
      TWDR = (SLA << 1) | TW_READ;
      TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWIE);
	  break;
    
    case TW_MR_SLA_ACK:
      // 6) get only one byte, send nack
  	  TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWIE);
      break;
    
    case TW_MR_DATA_NACK:
      // 7) receive data and updata leds
      getData = TWDR;
      digitalWrite(12, getData & 1);
      digitalWrite(11, (getData >> 1) & 1);
	  
      // 8) send stop condition
      TWCR = (1<<TWINT)|(1<<TWEN)| (1<<TWSTO) | (1<<TWIE);
      break;
    
    default:
      // 9) check for errors and if one occurs send stop condition
      TWCR = (1<<TWINT)|(1<<TWEN)| (1<<TWSTO) | (1<<TWIE);
      digitalWrite(10, HIGH);
  }
}
    // Ok, an interrupt occurred.
    // Is this interrupt related to the request above?
    // Let's check the appropriate flags to be sure...
    // Ok, it is, we now need to go one step further on the protocol...
    // For now, let's put a fail assert to be sure that we are reaching this
    // point:
    //_ceu_arduino_assert(0, 5);  // blinks 5 times periodically forever
    emit I2C_REQUEST_DONE(1,1);
end