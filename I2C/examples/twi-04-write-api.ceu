/*
The following program illustrates the process of master write using TWI via a ceu API.
This example shows multiple bytes data transfer
The program starts by setting the value of the Bit Rate (TWBR).
It triggers the interrupt by sending the start condition continously after the previous request is completed.
Since it is multiple bytes, a repeated start is sent. To view multiple bytes transfer see example 04.
The Start condition further changes the TWDR to SLA Write and the TWCR is set to resume the transfer.
Further, the TWDR is set to the value we are going to send. In this case count%2 which toggles the data as count is increased every time.


Testing:
    - 

Circuit :
    -
*/
#include "wclock.ceu"
native
    _TWI_vect,
;
native/pre do
    ##include <compat/twi.h>
    int SLA;
    int count=1;
end

var int requestmode=-1;// 0 for Write and 1 for Read
var u8 errorcode=1;
/*
errorcode :
  No error                 0
  Interrupt not triggered  1
  NACK received            2
  Other Errors             3
*/

var byte twi_transmit_buffer=0;// max buffer length = 1 in this 1 byte example
input  (u8,u8) I2C_REQUEST_DONE;

output (u8 address,byte&& buffer,u8 n_byte) I2C_REQUEST_SEND do
    outer.requestmode=0;// write mode
    {SLA=@address;}
    outer.twi_transmit_buffer = *buffer;
    {
      TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN)|(1<<TWIE);// start condition
    }
end

spawn async/isr [_TWI_vect] do
  
  {
    SLA=4;
    
    switch(TW_STATUS){
      
      case TW_START:
          if(@(outer.requestmode)!=-1){
            TWDR = (SLA << 1) | (@(outer.requestmode)); // SLA + Read/Write
            @(outer.requestmode)=-1;
            ceu_arduino_assert(0,3);
          }
          TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWIE); // Continue Transfer
          break;
      
      case TW_MT_SLA_ACK:
          @outer.errorcode = 0;
          TWDR = @(outer.twi_transmit_buffer);
          TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWIE);
          break;
      case TW_MT_SLA_NACK:
          @(outer.errorcode)=2;// in case of slave not connected or receiving NACK from slave
          break;
          
      default:
          @(outer.errorcode)=3;
          TWCR = (1<<TWINT)|(1<<TWEN)| (1<<TWSTO) | (1<<TWIE);//default case sends stop condition
    }
    
  }
  
  emit I2C_REQUEST_DONE(1,outer.errorcode);
  
end


{
    TWBR = ((F_CPU / 100000L) - 16) / 2;// Bit rate formula
}

loop do
    var byte sendData = 1-(_digitalRead (6) as byte);
    /*
    if sendData==1 then
      _digitalWrite(13,1);
    else
      _digitalWrite(13,0);
    end
    */
    emit I2C_REQUEST_SEND(4,&&sendData,1);
    var u8 nob;
    var u8 status;
    (nob,status) = await I2C_REQUEST_DONE;
    if status!=0 then
      _Serial.println("error occured");
    end
end
