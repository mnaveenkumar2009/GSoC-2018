/*
The following program illustrates the process of master write using TWI via a ceu API.
This example shows multiple bytes data transfer
The program starts by setting the value of the Bit Rate (TWBR).
It triggers the interrupt by sending the start condition continously after the previous request is completed.
Since it is multiple bytes, a repeated start is sent. To view multiple bytes transfer see example 04.
The Start condition further changes the TWDR to SLA Write and the TWCR is set to resume the transfer.
Further, the TWDR is set to the value we are going to send. In this case count%2 which toggles the data as count is increased every time.


Testing:
    - 

Circuit :
    -
*/
#include "wclock.ceu"
native
    _TWI_vect,
;
native/pre do
    ##include <compat/twi.h>
    int SLA;
    volatile int TXBuffIndex;
    int TXBuffLen;
end

var int requestmode=-1;// 0 for Write and 1 for Read
var u8 errorcode=1;
/*
errorcode :
  No error                 0
  Interrupt not triggered  1
  NACK received            2
  Other Errors             3
*/

#define TXMAXBUFLEN 32 // Transmit buffer length

var[TXMAXBUFLEN] byte twi_transmit_buffer=0;// max buffer length = 32
input  (u8,u8) I2C_REQUEST_DONE;

output (u8 address,byte&& buffer,u8 n_byte) I2C_REQUEST_SEND do
    outer.requestmode=0;// write mode
    {SLA=@address;}
    if n_byte>TXMAXBUFLEN
        n_byte=TXMAXBUFLEN; // trimming the data to fit buffer length
    end
    loop i in [0->(n_byte-1)] do
        outer.twi_transmit_buffer[i] = *(buffer+1);
    end
    {
      TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN)|(1<<TWIE);// start condition
    }
end

spawn async/isr [_TWI_vect] do
  
  {    
    switch(TW_STATUS){      
      case TW_START:
          if(@(outer.requestmode)!=-1){
            TWDR = (SLA << 1) | (@(outer.requestmode)); // SLA + Read/Write
            @(outer.requestmode)=-1;
            ceu_arduino_assert(0,3);
          }
          TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWIE); // Continue Transfer
          break;
      
      case TW_MT_SLA_ACK:
          @outer.errorcode = 0;
          TWDR = @(outer.twi_transmit_buffer);
          TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWIE);
          break;
      case TW_MT_SLA_NACK:
          @(outer.errorcode)=2;// in case of slave not connected or receiving NACK from slave
          break;
          
      default:
          @(outer.errorcode)=3;
          TWCR = (1<<TWINT)|(1<<TWEN)| (1<<TWSTO) | (1<<TWIE);//default case sends stop condition
    }    
  }
  
  emit I2C_REQUEST_DONE(1,outer.errorcode);
  
end


{TWBR = ((F_CPU / 100000L) - 16) / 2;}// Bit rate formula

loop do
    var[5] byte sendData = [0,1,2,3,4];
    emit I2C_REQUEST_SEND(4,&&sendData[0],5);
    await I2C_REQUEST_DONE;
end
