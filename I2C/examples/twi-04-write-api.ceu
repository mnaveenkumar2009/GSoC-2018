/*
The following program illustrates the process of master write using TWI via a ceu API.
This example shows multiple bytes data transfer
The program starts by setting the value of the Bit Rate (TWBR).
It triggers the interrupt by sending the start condition continously after the previous request is completed.
Since it is multiple bytes, a repeated start is sent. To view multiple bytes transfer see example 04.
The Start condition further changes the TWDR to SLA Write and the TWCR is set to resume the transfer.
Further, the TWDR is set to the value we are going to send. In this case count%2 which toggles the data as count is increased every time.


Testing:
    - 

Circuit :
    -
*/
#include "wclock.ceu"
native
    _TWI_vect,
;
native/pre do
    ##include <compat/twi.h>
    int SLA;
    volatile int TXBuffIndex=0;
    int TXBuffLen=0;
end

var int requestmode=-1;// 0 for Write and 1 for Read
var u8 errorcode=1;
/*
errorcode :
  No error                 0
  Interrupt not triggered  1
  NACK received            2
  Other Errors             3
*/

#define TXMAXBUFLEN 32 // Transmit buffer length

var[TXMAXBUFLEN] byte twi_transmit_buffer;// max buffer length = 32
var u8 i;
loop i in [1->TXMAXBUFLEN] do
    twi_transmit_buffer = twi_transmit_buffer .. [0];
end

input  (u8,u8) I2C_REQUEST_DONE;

output (u8 address,byte&& buffer,u8 n_byte) I2C_REQUEST_SEND do
    outer.requestmode=0;// write mode
    {   
        SLA=@address;
        TXBuffIndex = 0;
        TXBuffLen = @n_byte;
    }
    if n_byte>TXMAXBUFLEN then
        n_byte=TXMAXBUFLEN; // trimming the data to fit buffer length
    end
    var u8 i;
    loop i in [0->(n_byte-1)] do
        outer.twi_transmit_buffer[i] = buffer[i];
    end
    {
      TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN)|(1<<TWIE);// start condition
    }
end

spawn async/isr [_TWI_vect] do
  
  { 
    switch(TW_STATUS){
    
        case TW_START:
            @(outer.errorcode) = 0;
            if(@(outer.requestmode)!=-1){
                TWDR = (SLA << 1) | @(outer.requestmode); // SLA + Read/Write (Write in this case)
            }
            TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWIE); // Continue Transfer
            break;
      
        case TW_MT_SLA_ACK:
            if(TXBuffIndex<TXBuffLen){
                TWDR = @(outer.twi_transmit_buffer[{TXBuffIndex++}]);
                TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWIE);
            }
            else{
                TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWIE) | (1<<TWSTO);
            }
            break;
        case TW_MT_DATA_ACK:
            TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWIE)|(1<<TWSTA);// Send Repeated Start
	        break;
        case TW_REP_START:
      		TWDR = (SLA << 1) | @(outer.requestmode);// SLA + Read/Write (Write in this case)
    		TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWIE);
    		break;
        case TW_MT_SLA_NACK:
        case TW_MT_DATA_NACK:
            @outer.errorcode=2;// in case of slave not connected or receiving NACK from slave or requesting more data from the slave than the amount sent
            TWCR = (1<<TWINT)|(1<<TWEN)| (1<<TWSTO) | (1<<TWIE);
            break;
        default:
            @outer.errorcode=3;
            TWCR = (1<<TWINT)|(1<<TWEN)| (1<<TWSTO) | (1<<TWIE);//default case sends stop condition
    }
  }
  
  emit I2C_REQUEST_DONE(1,outer.errorcode);
  
end


{TWBR = ((F_CPU / 100000L) - 16) / 2;}// Bit rate formula

loop do
    var[5] byte sendData = [0,1,2,3,4];
    emit I2C_REQUEST_SEND(4,&&sendData[0],5);
    await I2C_REQUEST_DONE;
end
