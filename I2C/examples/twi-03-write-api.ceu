/*
The following program illustrates the process of master write of 1 byte data using TWI via a ceu API.
This example shows 1 byte data transfer
The program starts by setting the value of the Bit Rate (TWBR).
It triggers the interrupt by sending the start condition continously after the previous request is completed.
Since it is only 1 byte, a repeated start isn't sent. To view multiple bytes transfer see example 04.
The Start condition further changes the TWDR to SLA Write and the TWCR is set to resume the transfer.
Further, the TWDR is set to the value we are going to send. In this case it is !(input in pin 6) which is passed as an argument to the output


Testing:
    - The ACK from the slave was acheived by a fully connected master slave TWI system and the slave outputs the data received to Serial to see the data.
    - When a wrong address is mentioned or the slave is disconnected the NACK is assumed and the assert is called accordingly.
    - Removing the loop and writing await FOREVER at end to stop program from termination causes the program to send the request only once and write only once. This can be observed in the Serial monitor of the slave.


Circuit :
    - SDA,SCL lines of both master and slave pulled up by a resistor to 5V.
    - 5V and GND of both master and slave connected respectively to operate both at same voltage.
    - A pushbutton that is grounded on one end and the middle connected to pin 6 of master.
    - an LED connected to the slave that is set to the data received to observe the output or a Serial monitor to display the data received.
*/
#include "wclock.ceu"
native
    _TWI_vect,
;
native/pre do
    ##include <compat/twi.h>
    int SLA;
    int count=1;
end
{pinMode(6,INPUT_PULLUP);}
var int requestmode=-1;// 0 for Write and 1 for Read
var u8 errorcode=1;
/*
errorcode :
  No error                 0
  Interrupt not triggered  1
  NACK received            2
  Other Errors             3
*/

var byte twi_transmit_buffer=0;// max buffer length = 1 in this 1 byte example
input  (u8,u8) I2C_REQUEST_DONE;

output (u8 address,byte&& buffer,u8 n_byte) I2C_REQUEST_SEND do
    outer.requestmode=0;// write mode
    {SLA=@address;}
    outer.twi_transmit_buffer = *buffer;
    {
      TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN)|(1<<TWIE);// start condition
    }
end

spawn async/isr [_TWI_vect] do
  
  {
    switch(TW_STATUS){
      
        case TW_START:
            @outer.errorcode = 0;
            if(@(outer.requestmode)!=-1){
                TWDR = (SLA << 1) | (@(outer.requestmode)); // SLA + Read/Write
                @(outer.requestmode)=-1;
            }
            TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWIE); // Continue Transfer
            break;
      
        case TW_MT_SLA_ACK:
            TWDR = @(outer.twi_transmit_buffer);
            TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWIE);
            break;
        case TW_MT_DATA_ACK:
            TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWIE) | (1<<TWSTO); // send stop after sending
            break;
        case TW_MT_SLA_NACK:
            @(outer.errorcode)=2;// in case of slave not connected or receiving NACK from slave
            TWCR = (1<<TWINT)|(1<<TWEN)| (1<<TWSTO) | (1<<TWIE);
            break;
          
        default:
            @(outer.errorcode)=3;
            TWCR = (1<<TWINT)|(1<<TWEN)| (1<<TWSTO) | (1<<TWIE);//default case sends stop condition
    } 
  }  
  emit I2C_REQUEST_DONE(1,outer.errorcode);
end


{
    TWBR = ((F_CPU / 100000L) - 16) / 2;// Bit rate formula
}

loop do
    var byte sendData = 1-(_digitalRead (6) as byte);
    emit I2C_REQUEST_SEND(4,&&sendData,1);
    var u8 nob;
    var u8 status;
    (nob,status)=await I2C_REQUEST_DONE;
    if status!=0 then
        _ceu_arduino_assert(0,errorcode);
    end
end