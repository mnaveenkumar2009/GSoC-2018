/*
The following program illustrates the process of master write using TWI via a ceu API.
This example shows multiple bytes data transfer
The program starts by setting the value of the Bit Rate (TWBR).
It triggers the interrupt by sending the start condition continously after the previous request is completed.
The Start condition further changes the TWDR to SLA Write and the TWCR is set to resume the transfer.
Once an ACK is received, The interrupts sends the data one by one until all data is sent or a NACK is received.
This data is sent by setting TWDR to the data we want to send.


Testing:
    - The data is sent successfully continously with a proper master slave system connected where the slave sends ACK on data received.
    - Removing the loop and adding await forever at the end sends the data only once as expected
    - When a wrong address is mentioned or slave doesn't acknowledge the data a NACK is assumed/received and no data is sent.

Circuit :
    - SDA,SCL lines of both master and slave pulled up by a resistor to 5V.
    - 5V and GND of both master and slave connected respectively to operate both at same voltage.
    - A Serial monitor to display the data received in the slave.
*/
#include "wclock.ceu"
native
    _TWI_vect,
;
native/pre do
    ##include <compat/twi.h>
    int SLA;
    volatile int TXBuffIndex=0;
    int TXBuffLen=0;
end
var int requestmode=-1;// 0 for Write and 1 for Read
var u8 errorcode=1;
/*
errorcode :
  No error                 0
  Interrupt not triggered  1
  NACK received            2
  Other Errors             3
*/

#define TXMAXBUFLEN 32 // Transmit buffer length
var[TXMAXBUFLEN] byte twi_transmit_buffer;// max buffer length = 32

input  (u8,u8) I2C_REQUEST_DONE;

output (u8 address) I2C_REQUEST_SEND do
    outer.requestmode=0;// write mode
    {   
        SLA=@address;
        TXBuffIndex = 0;
        TXBuffLen = @($outer.twi_transmit_buffer);
    }
    {TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN)|(1<<TWIE);}// start condition
end

spawn async/isr [_TWI_vect] do
  var bool done = false;
  { 
    switch(TW_STATUS){
    
        case TW_START:
        case TW_REP_START:
            @(outer.errorcode) = 0;
            if(@(outer.requestmode)!=-1){
                TWDR = (SLA << 1) | @(outer.requestmode); // SLA + Read/Write (Write in this case)
                TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWIE) | (1<<TWEA); // Continue Transfer
            }
            else{
                TWCR = (1<<TWINT)|(1<<TWEN)| (1<<TWSTO) | (1<<TWIE); // send stop
                @done=1;
            }
            break;
      
        case TW_MT_SLA_ACK:
        case TW_MT_DATA_ACK:
            if(TXBuffIndex<TXBuffLen){
                TWDR = @(outer.twi_transmit_buffer[{TXBuffIndex++}]);
                TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWIE) | (1<<TWEA);
            }
            else{
                TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWIE) | (1<<TWSTO) | (1<<TWEA);
                @done=1;
            }
            break;
        case TW_MT_SLA_NACK:
        case TW_MT_DATA_NACK:
            @outer.errorcode=2;// in case of slave not connected or receiving NACK from slave or requesting more data from the slave than the amount sent
            @done=1;
            TWCR = (1<<TWINT)|(1<<TWEN)| (1<<TWSTO) | (1<<TWIE);
            break;
        default:
            @outer.errorcode=3;
            @done=1;
            TWCR = (1<<TWINT)|(1<<TWEN)| (1<<TWSTO) | (1<<TWIE);//default case sends stop condition
    }
  }
  if done then
    emit I2C_REQUEST_DONE({TXBuffLen},outer.errorcode);
    outer.twi_transmit_buffer = [];
  end
end


{TWBR = ((F_CPU / 100000L) - 16) / 2;}// Bit rate formula

loop do
    twi_transmit_buffer = twi_transmit_buffer .. [0,1,2];
    emit I2C_REQUEST_SEND(4);
    await I2C_REQUEST_DONE;
end